## bespoke hash function

MDM-255/128/32 = MiMC in Davies-Meyer mode with 255 bit field, 128 rounds, and
32 keys.  Round constants (unspecified in MiMC paper) are generated from
fractional bits of pi for the first round and repeatedly squared for
subsequent.  Round count lowered from 161 to 128 because our limiting attack is
generic collisions; this hash probably does not achieve 2^255 preimage
security.

## motivating the field size

MDM-ish hash functions require fields of odd dimenson and at least 128ish (for
the Feistel version), although the non-Feistel version uses half as many
rounds.

FRI and the multi-function test described here have security terms of the
inverse field size; below 148 will weaken FRI.

FRI, constraint generation, and the Gao-Mateer FFT can all in various ways
leverage subfields near the problem size, and a subfield-rich field is
advantageous.

## multi-polynomial statements

A multi-polynomial statement consists of an affine set of points (constrained
set), a number of variables defined on the constrained set, and a set of
constraint polynomials with limited total degree (2 or 3) in the variables and
affine shifts of variables.  The constraint polynomials may have high degree in
the coordinate and parameters, but must then be expressed as an arithmetic
circuit.

## non-closed shifts

The papers use shifts that do not close the evaluation set; I'm not sure how
verification is supposed to work with that.  Until I figure it out, we can use
unital shifts, which are unfortunately commutative so we need log(n) of them
instead of 2.

## multi-polynomial proofs

A multi-polynomial proof begins with a satisfying assignment for the variables
on the constrained set.  These are then interpolated to produce one polynomial
per variable and evaluated on a (larger, non-overlapping) affine set of points;
for each constraint, an auxilliary polynomial is generated by using the
evaluation results and dividing by a zero-locus polynomial for the constraint
set.  For cubic polynomials it may be needed to split the auxilliary polynomial
into two polynomials of half degree; this can be done using 1 round each of the
inverse and forward aFFT.

A non-succinct proof is valid if the claimed low-degree polynomials are
actually low degree and if evaluating each constraint produces the
corresponding auxilliary polynomial

A proof can be interactively verified; the verifier challenges the prover with
a random linear combination, the prover responds with a combined polynomial,
then a FRI protocol is used to verify the degree of the combined polynomial
while the verifier performs spot checks to check the combined polynomials
against the original polynomial and constraint set.  Zero knowledge can be
added at the cost of one dummy variable and ca. 1000 dummy points in each real
variable.

## proof that it is sufficient to run FRI on the linear combination

Suppose that f[1] ... f[k] are approximate codewords in some linear code of
dimension z and distance h over F, and that a random linear (affine)
combination of the fs is within distance eps of a codeword, eps < h/4, with
probability p + |F|^-k, p > 2 / (|F| - 1).  Then there exists a set S of at
most eps (1 + k / floor(p/2 (|F|-1))) codeword positions such that the error of
each f[i] is contained in S.

Proof:

Let eps' <= eps < h/4 be the largest distance at most eps which is achieved by
a linear combination.  Let O be the coordinate of a linear combination which
reaches eps'.  There are a fraction p of better linear combinations on (|F|^k -
1) / (|F| - 1) disjoint lines passing through O; a fraction p/2 of such lines
must have p/2 better linear combinations each.

Let DO be the difference between O's combination and the (unique) nearest
codeword; DO's support has size |DO| = eps'.

The total volume of these lines is greater than the volume of a hyperplane so
they span the linear space.  Let B be a linearly independent subset of lines
with >= p/2 eps-points (eps'-points) each; |B| = k.

Each line ell in B has at least q = fl(1 + p(|F|-1)/2) eps'-points; pick one
other than O and call it P[ell], defining DP[ell] as for DO.  Every point on
ell can be obtained as a linear combination of O and P[ell]; let S[ell] be the
union of the supports of DO and DP[ell], and thus a superset of the error
support for each point on ell, immediately |S[ell]| <= 2eps.

Each error position in S[ell] is linear along ell, does not vanish identically,
and thus vanishes at exactly one point.  Each eps'-point requires the error to
vanish at |S[ell]|-eps positions, thus q(|S[ell]|-eps') <= |S[ell]|, |S[ell]| <=
eps' q/(q-1), |S[ell]-DO|=|S[ell]|-eps' <= eps'/(q-1).

Let S be the union of S[ell] for each ell in B.  |S-DO| <= eps' k/(q-1) and S
bounds the error of a linearly independent set of points, thus the whole space,
including the fs.

## contents of a succinct proof

* Merkle root for the interleaved variable assignment functions; root is used
  as a PRF seed to generate multipliers

* Merkel root for the degree-test functions; this root and previous are used in
  PRF to generate test positions and the first PRI challenge

* Nc consistency checks; authentication paths into the first two roots to
  verify that the test function is close to the correct combination of
  assignment functions

* PRI commitment roots for the degree-test function

* Np PRI query paths

## parameters

MACSP parameters:

* P: number of points

* V: variables per point

* Vs: shifted variables per point

* C: constraints per point

These are largely determined by the problem, but some trading between p and the
others is often possible.

Main IP paramters:

* Nc: number of consistency checks between the assignment functions and test
  function

* R: fractional code rate

FRI parameters:

* Eta: interpolation degree, usually 4

* Nr: number of consistency checks between FRI rounds

Fiat-Shamir parameters:

* Merkle tree radix: 32?

* Mixing between coordinate Merkle layers and variable Merkle layers: enables
  prover memory reduction

The basic SNARK parameters are "recurion optimized" in that they seek to
minimize the cost of proving the verification program.

A full parameter optimization is TBD but R=1/8, Nr=Nc=546 suffices for 2^-128
soundness.

## intuition for aFFT and FRI

A polynomial of degree n can be expressed as a polynomial of degree n/k in a
degree k polynomial and a degree \<k leftover.  If the short polynomial is a
subspace quotient polynomial, the polynomial can then be evaluated at n/k
points instead of n points, resulting in degree \<k polylets to evaluate at the
original n points.  The affine FFT uses a special degree k polynomial which can
be expanded without multiplications; a more general affine FFT would require
extra multiplications, but FRI can stop before that point.
